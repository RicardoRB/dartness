# Exceptions

Exception is a class that is used to represent an error condition, it is usually used to change your business logic
or response in your API.

Dartness provides different ways to handle or throw exceptions.

## HttpStatusException

HttpStatusException is a class that is extended from Exception class and is used to throw an exception with a specific
HTTP status code. Use this class to throw an exception when you want to return a specific HTTP status code. If the
exception thrown is not handled by the client, the default status code is 500. You can find and example below:

```dart
class NotFoundException extends HttpStatusException {
  const NotFoundException(String message) : super(message, HttpStatus.notFound);
}
```

## Global ErrorHandler

### Code generation

Error handlers use the code generation mechanism in order to provide reflection possible thanks to
the [Dart Build System](https://github.com/dart-lang/build). This means that when generating the code the error handlers
will have two parts, one done by the developer and other one automatically generated by `dartness_generator`.

Once you have added the annotations and added the corresponding `part '*.g.dart';` to your code you then need to run the
code generator to generate the
missing `.g.dart` generated dart files.

Run `dart run build_runner build` in the package directory to generate the missing parts.

Dartness provides with a built-in exceptions layer which is responsible for processing all unhandled exceptions across
an
application. When an exception is not handled by your application code, it is caught by this layer, which allow you to
create a logic when an exception occurs including returning a specific response.

An error handle is any kind of class that is annotated with `@ErrorHandler` and implements one or more methods that is
annotated with `@CatchError`. This method will handle the corresponding exception or exceptions that you want to catch.

You can find an example below:

#### One exception

```dart
part 'error_handler.g.dart';

@ErrorHandler()
class ErrorHandler {

  @CatchError([NotFoundException])
  DartnessResponse handleNotFoundException(NotFoundException error) {
    return Response.notFound(error.message);
  }

}
```

#### Multiple exceptions

```dart 

part 'error_handler.g.dart';

@ErrorHandler()
class ErrorHandler {

  @CatchError([ForbiddenException, UnauthorizedException])
  DartnessResponse handleMultipleException(Exception error) {
    return Response.unauthorized(error.message);
  }

}
```

> **_NOTE:_** `@CatchError` accept multiple errors as a list parameter, in order to get the specific error as parameter,
> you need to just specify only 1 error. Otherwise, the error parameter should be a parent of them. Usually, `Error` or
> `Exception`.

### Adding Error Handler to your application

Dartness accept multiple error handling layers, you can add your own error handling layer to your application by
send them to the `addErrorHandler` method or by name parameter.

The param accept the objects with a wrapper called `DartnessErrorHandler`, this class receives 2 parameters,
the instance of the error handler and the catch errors automatically generated by the class annotated by `@ErrorHandler`
. A good way to send yours error handlers is using the function `map` that `Iterable` provides as we see in the
following example:

```dart
void main() async {
  final errorHandlers = [ExampleErrorHandler()];
  final app = Dartness(
    port: 3000,
    errorHandlers: errorHandlers.map((errorHandler) =>
        DartnessErrorHandler(errorHandler, errorHandler.getCatchErrors())),
  );
  await app.create();
}
```